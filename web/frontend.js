// Generated by CoffeeScript 1.6.2
(function() {
  var C, Frontend, Renderer, WAIT_FACTOR, simulator_draw;

  C = (function() {
    function C() {}

    C.X_BOUND = $(window).width();

    C.Y_BOUND = $(window).height();

    C.DISPLAY_BOUND = 0;

    C.INFO_WINDOW = false;

    C.TWO_TRADEOFF = false;

    C.HARSH_REPRODUCTION = false;

    C.NEIGHBOR_DISTANCE = 20;

    C.CHILD_DISTANCE = 20;

    C.ATTACK_MARGIN = 100;

    C.STARTING_ENERGY = 200;

    C.STARTING_BLOBS = 100;

    C.MOVEMENT_PER_ENERGY = 100;

    C.REPR_ENERGY_COST = 2000;

    C.MOVEMENT_SPEED_FACTOR = .3;

    C.PHO_EPS = .05;

    C.PHO_SQ_EPS = .15;

    C.ATK_EPS = -.5;

    C.ATK_SQ_EPS = 0;

    C.SPD_EPS = 0;

    C.AGE_ENERGY_DECAY = .5;

    C.RADIUS_FACTOR = .1;

    C.RADIUS_CONSTANT = 1;

    C.BLOB_SIZE = 1.0;

    C.ENERGY_DECAY = .005;

    C.REPR_TIME_REQUIREMENT = 7;

    C.MUTATION_PROBABILITY = .1;

    C.MUTATION_CONSTANT = .5;

    C.QTREE_BUCKET_SIZE = 50;

    C.FRAME_RATE = 60;

    C.MOVE_UPDATE_AMT = 5;

    return C;

  })();

  WAIT_FACTOR = 1.1;

  Renderer = (function() {
    function Renderer(frontend, p) {
      this.frontend = frontend;
      this.p = p;
      this.frames = 0;
      this.frameRate = C.FRAME_RATE;
      this.framesUntilUpdate = 1;
      this.colors = {};
      this.futureColors = {};
      this.currentState = {};
      this.futureState = {};
      this.delta = {};
      this.updateAvailable = false;
      this.update = [];
      this.thunks = 0;
      this.requestUpdate();
      this.lastFrame = Date.now();
      this.removedLastStep = [];
    }

    Renderer.prototype.step = function() {
      var currentTime;

      this.frames++;
      currentTime = Date.now();
      this.lastFrame = currentTime;
      if (this.framesUntilUpdate === 0) {
        if (this.updateAvailable) {
          if (this.thunks > 0) {
            WAIT_FACTOR += .05;
            WAIT_FACTOR *= 1.05;
            console.log("Thunked " + this.thunks + " times");
            this.thunks = 0;
          }
          this.processUpdate();
        } else {
          this.thunks++;
        }
      }
      if (!this.thunks) {
        return this.drawAll();
      }
    };

    Renderer.prototype.drawBlob = function(state, color) {
      var blu, grn, r, red, x, y;

      x = state[0], y = state[1], r = state[2];
      red = color[0], grn = color[1], blu = color[2];
      this.p.noStroke();
      this.p.fill(red, grn, blu);
      return this.p.ellipse(x, y, 2 * r, 2 * r);
    };

    Renderer.prototype.drawAll = function() {
      var id, state, _ref;

      this.p.background(0, 40, 0);
      _ref = this.currentState;
      for (id in _ref) {
        state = _ref[id];
        state[0] += this.delta[id][0];
        state[1] += this.delta[id][1];
        state[2] += this.delta[id][2];
        this.drawBlob(state, this.colors[id]);
      }
      return --this.framesUntilUpdate;
    };

    Renderer.prototype.requestUpdate = function() {
      this.requestTime = Date.now();
      return this.frontend.requestUpdate();
    };

    Renderer.prototype.receiveUpdate = function(update) {
      this.update = update;
      this.timeElapsed = Date.now() - this.requestTime;
      return this.updateAvailable = true;
    };

    Renderer.prototype.processUpdate = function() {
      var addedBlobs, c, dr, dx, dy, id, rc, removedBlobs, rf, xc, xf, yc, yf, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;

      this.updateAvailable = false;
      this.requestUpdate();
      this.currentState = this.futureState;
      this.futureState = this.update.blobs;
      removedBlobs = this.update.removed;
      addedBlobs = this.update.added;
      for (id in addedBlobs) {
        c = addedBlobs[id];
        this.colors[id] = c;
      }
      _ref = this.removedLastStep;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        delete this.colors[id];
      }
      this.framesUntilUpdate = Math.ceil(WAIT_FACTOR * this.timeElapsed / this.frameRate);
      if (this.framesUntilUpdate < 4) {
        this.framesUntilUpdate = 4;
      }
      _ref1 = this.futureState;
      for (id in _ref1) {
        _ref2 = _ref1[id], xf = _ref2[0], yf = _ref2[1], rf = _ref2[2];
        if (!(id in this.currentState)) {
          this.currentState[id] = [xf, yf, 0];
        }
        _ref3 = this.currentState[id], xc = _ref3[0], yc = _ref3[1], rc = _ref3[2];
        dx = (xf - xc) / this.framesUntilUpdate;
        dy = (yf - yc) / this.framesUntilUpdate;
        dr = (rf - rc) / this.framesUntilUpdate;
        this.delta[id] = [dx, dy, dr];
      }
      for (_j = 0, _len1 = removedBlobs.length; _j < _len1; _j++) {
        id = removedBlobs[_j];
        if (id in this.currentState) {
          dr = -this.currentState[id][2] / this.framesUntilUpdate;
          this.delta[id] = [0, 0, dr];
        } else {
          console.log("blob " + id + " was listed as removed but not found in state");
        }
      }
      return this.removedLastStep = removedBlobs;
    };

    return Renderer;

  })();

  Frontend = (function() {
    function Frontend(p) {
      var _this = this;

      this.p = p;
      this.running = true;
      this.sim = new Worker('simulation.js');
      this.sim.onmessage = function(event) {
        switch (event.data.type) {
          case 'blobs':
            return _this.renderer.receiveUpdate(event.data);
          case 'debug':
            return console.log(event.data.msg);
        }
      };
      this.updateConstants();
      this.setupGui();
      this.addBlobs(C.STARTING_BLOBS);
      this.renderer = new Renderer(this, this.p);
      this.running = true;
      $(window).resize(function() {
        console.log("Resizing");
        C.X_BOUND = $(window).width();
        C.Y_BOUND = $(window).height();
        _this.p.size(C.X_BOUND, C.Y_BOUND);
        return _this.updateConstants();
      });
    }

    Frontend.prototype.updateConstants = function() {
      var k, newC, v;

      newC = {};
      for (k in C) {
        v = C[k];
        newC[k] = v;
      }
      return this.sim.postMessage({
        type: 'updateConstants',
        data: newC
      });
    };

    Frontend.prototype.setupGui = function() {
      var addSlider, gui, opt,
        _this = this;

      opt = {};
      opt['Kill all blobs'] = function() {
        return _this.sim.postMessage({
          type: 'killAllBlobs'
        });
      };
      opt['Kill most blobs'] = function() {
        return _this.sim.postMessage({
          type: 'killMostBlobs'
        });
      };
      opt['Add a blob'] = function() {
        return _this.sim.postMessage({
          type: 'addRandomBlob'
        });
      };
      gui = new dat.GUI();
      addSlider = function(name, min, max, step) {
        if (step == null) {
          step = (max - min) / 100;
        }
        return gui.add(C, name, min, max, step).onFinishChange(function(newVal) {
          return _this.updateConstants();
        });
      };
      addSlider('REPR_ENERGY_COST', 100, 2000);
      addSlider('PHO_EPS', 0, 1.0);
      addSlider('PHO_SQ_EPS', 0, .2);
      addSlider('ATK_EPS', -1.0, 1.0);
      addSlider('ATK_SQ_EPS', -.2, .2);
      addSlider('BLOB_SIZE', 0.1, 5);
      addSlider('MUTATION_CONSTANT', .01, 1);
      addSlider('MUTATION_PROBABILITY', 0, .5);
      addSlider('ENERGY_DECAY', 0, .1);
      addSlider('AGE_ENERGY_DECAY', 0, 1);
      gui.add(opt, 'Kill all blobs');
      gui.add(opt, 'Add a blob');
      gui.add(opt, 'Kill most blobs');
      this.showNucleus = false;
      this.showShells = false;
      return this.showReproduction = false;
    };

    Frontend.prototype.step = function() {
      if (this.running) {
        return this.renderer.step();
      }
    };

    Frontend.prototype.requestUpdate = function() {
      return this.sim.postMessage({
        type: 'go'
      });
    };

    Frontend.prototype.addBlobs = function(n) {
      return this.sim.postMessage({
        type: 'addBlobs',
        data: n
      });
    };

    Frontend.prototype.keyCode = function(k) {
      if (k === 32) {
        this.running = !this.running;
      }
      if (k === 78) {
        this.showNucleus = !this.showNucleus;
      }
      if (k === 83) {
        this.showShells = !this.showShells;
      }
      if (k === 82) {
        return this.showReproduction = !this.showReproduction;
      }
    };

    return Frontend;

  })();

  simulator_draw = function(p) {
    var frontend;

    frontend = new Frontend(p);
    p.mouseClicked = function() {
      return frontend.mouseClick(p.mouseX, p.mouseY);
    };
    p.setup = function() {
      p.frameRate(C.FRAME_RATE);
      p.size(C.X_BOUND, C.Y_BOUND);
      return p.background(0, 20, 90);
    };
    p.draw = function() {
      return frontend.step();
    };
    return p.keyPressed = function() {
      console.log(p.keyCode);
      return frontend.keyCode(p.keyCode);
    };
  };

  $(document).ready(function() {
    var canvas, processing;

    canvas = document.getElementById("processing");
    return processing = new Processing(canvas, simulator_draw);
  });

}).call(this);
